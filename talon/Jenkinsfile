/* Before using this example, check if the below release tag(v0.3.0) is the latest.
 * You can find the latest release tag at https://git.soma.salesforce.com/dci/sfci-pipeline-sharedlib/releases
 */
@Library('sfci-pipeline-sharedlib@master') _

/* import is required only if you use one of the classes specified here:
 * https://git.soma.salesforce.com/dci/sfci-pipeline-sharedlib#classes
 */
import net.sfdc.dci.BuildUtils
import net.sfdc.dci.GitHubUtils
import groovy.json.JsonOutput

/* Specify the build image you want to use.
 * This build image uses https://git.soma.salesforce.com/communities/centos-sfci-nodejs-puppeteer
 * Not specifying a build image will use the default build image specified here:
 * https://git.soma.salesforce.com/dci/sfci-pipeline-sharedlib/blob/master/vars/executePipeline.groovy#L4
 */
def envDef = [ buildImage: 'ops0-artifactrepo1-0-prd.data.sfdc.net/communities/centos-sfci-nodejs-puppeteer:latest' ]
def stagingProfileId = '58da552823cd6'

// define any release branches here
env.RELEASE_BRANCHES = ['220', '218', '216']

// The checked-out revision / commit information.
// We use this elsewhere and leak it here for convenience.
gitRepo = null
commitSha = null

executePipeline(envDef) {

    // Checkout the commit and extract some useful values.
    echo 'Checking out git repo...'
    stage('Checkout') {
        revision = checkout scm
        gitRepo = revision.GIT_URL
        commitSha = revision.GIT_COMMIT
    }

    stage('NPM') {
        stage('NPM Init') {
            npmInit(null)
        }
        stage('NPM Install') {
            sh 'npm_config_tarball=/usr/lib/node-v10.13.0-headers.tar.gz yarn install'
        }
        stage('NPM Build') {
            sh 'yarn build'
        }        
        stage('Code Validation') {
            parallel([
                failFast: true,
                "Code Conformance": {
                    reportStepsToCurrentCommitGitHubStatus('Code Conformance') {
                        sh 'yarn lint'
                    }
                },
                "Jest Tests": {
                    reportStepsToCurrentCommitGitHubStatus('Code Coverage') {
                        sh 'yarn coverage'
                    }
                },
                "Integration Tests": {
                    reportStepsToCurrentCommitGitHubStatus('Integration Tests') {
                        sh 'yarn test:integration'
                    }
                }
            ])
        }
        stage('Collect Reports') {
            publishHTML([
                allowMissing: false,
                alwaysLinkToLastBuild: false,
                keepAll: false,
                reportDir: 'jest-report',
                reportFiles: 'index.html',
                reportName: 'JEST Results',
                reportTitles: ''
            ])
            publishHTML([
                allowMissing: false,
                alwaysLinkToLastBuild: false,
                keepAll: false,
                reportDir: 'coverage/lcov-report',
                reportFiles: 'index.html',
                reportName: 'JEST Coverage',
                reportTitles: ''
            ])
        }  
    }

    stage('Maven') {
        stage('Initialize') {
            mavenInit()
        }  
        if (BuildUtils.isPullRequestBuild(env) || BuildUtils.isReleaseBuild(env)) {
            stage('Build') {
                reportStepsToCurrentCommitGitHubStatus('Maven Build') {
                    withEnv(["COMPILE_LWC_COMPONENTS=true"]) {
                        mavenVersionsSet([managed : true])
                        mavenBuild()
                    }
                }
            }
            // If this is a release build, we can stage and release the artifacts.
            if (BuildUtils.isReleaseBuild(env)) {
                stage('Stage Artifacts') {
                    reportStepsToCurrentCommitGitHubStatus('Artifact Staging') {
                        mavenStageArtifacts([staging_profile_id : stagingProfileId])
                    }
                }
            //  TODO: reenable when itests back running, and fewer breaking changes :( 
            //    stage('Trigger Core Itests') {
            //        env.AUTOBUILD_ENV = 'prod'
            //        reportStepsToCurrentCommitGitHubStatus('Core Integration Tests') {
            //            triggerCoreItests()
            //        }
            //    }
                stage('Release') {
                    reportStepsToCurrentCommitGitHubStatus('Artifact Promotion to Release') {
                        mavenPromoteArtifacts()
                    }
                }
                stage('GUS Compliance'){
                    git2gus()
                }
            }
        } else {
            mavenBuild()
        }
    }
}

/**
 *  Reports the progress and outcome of one or more steps to GitHub as the status of a GitHub Status API context.
 *  The specified GitHub Status API context will be marked as "pending" before the steps are executed.
 *  If the steps throw an error, the context will be marked as "failure"; otherwise, it will be marked as "success".
 *
 *  @param  gitHubStatusApiContextName
 *      The name of the GitHub Status API context to which the progress of the steps are reported.
 *
 *  @param  steps
 *      The build steps to execute.
**/
void reportStepsToCurrentCommitGitHubStatus(String gitHubStatusApiContextName, Closure steps) {

    setCurrentCommitStatus([state: 'pending', context: gitHubStatusApiContextName])
    try {
        steps()
        setCurrentCommitStatus([state: 'success', context: gitHubStatusApiContextName])
    }
    catch (e) {
        setCurrentCommitStatus([state: 'failure', context: gitHubStatusApiContextName, description: e.getMessage()])
        
        // We are just spying on any errors for reporting purposes, so re-throw.
        throw e
    }
}

/**
 *  Sets the GitHub API Status for the current (ambient) commit.
 *
 *  @param  status
 *      A set of GitHub Status API parameters that specify the status of the commit, as supported by https://developer.github.com/v3/repos/statuses/#create-a-status.
 **/
void setCurrentCommitStatus(status) {

    // If no explicit target_url has been set, use this build.
    status.target_url = status.target_url ?: env.BUILD_URL
    setCommitStatus(gitRepo, commitSha, status)
}

/**
 *  Sets the status of a GitHub commit.
 *
 *  @param  repositoryUri
 *      The URI of the GitHub repository (with or without a ".git" suffix) to which the status is reported.
 *  @param  commitSha
 *      The commit (e.g. SHA1) to which the status is associated.
 *  @param  status
 *      The status to set for the commit, as supported by https://developer.github.com/v3/repos/statuses/#create-a-status.
 *
 *  @returns
 *      The HTTP response of the status operation.
**/
void setCommitStatus(repositoryUri, commitSha, status) {

    // Extract the host, org, and repo from the commit checkout.
    // We'll find this in repositoryUri, which looks like "https://git.soma.salesforce.com/FeedsUI/ui-feeds-components.git"
    String[] repositoryUriParts = repositoryUri.split("/")

    String host = repositoryUriParts[2]
    String org = repositoryUriParts[3]
    String repo = repositoryUriParts[4].replace(".git", "") // Remove any trailing ".git" repository specifier
    String credentialsId = "sfci-git"   // Set by Jenkins (see https://git.soma.salesforce.com/dci/sfci-pipeline-sharedlib for an example)
    
    // Use the utility to form up our base URI to GitHub.
    String repositoryBaseUri = GitHubUtils.apiV3Repos(host, org, repo)

    // Use the GitHub Status API endpoint for this specific commit.
    String commitStatusUri = "${repositoryBaseUri}/statuses/${commitSha}"

    // Override the default content and accept types of application/json
    // by specifying NOT_SET and providing them as custom headers
    customHeaders = GitHubUtils.previewCustomHeaders(this, credentialsId)

    // POST the status to GitHub
    doPost(commitStatusUri, status, customHeaders, null, null)
}

/**
 * This method is stolen from BuildUtils.doPost, but modified to properly support parallel build steps.
 *
 * This method performs a HTTP POST request on requested resource and returns the response as a groovy map.
 * customHeaders is an array of maps, accepted keys as 'name' - Name of the header, 'value' - Value of the header
 * postBody can be a map or an array or any groovy primitive type, the method will convert it into a valid json string for the request.
 * Ex: [[name: 'Authorization', value: 'token sometoken'], [name: 'Accept', value: 'application/vnd.github.v3+json']]
 * The method produces a response of type groovy map, with key 'status' - response status code from the api request, 'content' - json response as groovy map
 *
 * Note: to override the {@code Content-Type} or {@code Accept} headers you
 * must set the corresponding {@code contentType} or {@code acceptType}
 * parameters to 'NOT_SET' then override them in {@code customHeaders}.
 *
 * For the supported types, refer to:
 * http://javadoc.jenkins-ci.org/http_request/jenkins/plugins/http_request/MimeType.html
**/
def doPost(def url, def postBody, def customHeaders, def contentType, def acceptType) {
    def bodyAsString = JsonOutput.toJson(postBody)
    def apiResponse = httpRequest(
            url: url,
            httpMode: 'POST',
            customHeaders: customHeaders ?: [],
            contentType: contentType ?: 'APPLICATION_JSON',
            acceptType: acceptType ?: 'APPLICATION_JSON',
            requestBody: bodyAsString
            )
    def json = readJSON([text: apiResponse.content])
    def response = [status: apiResponse.status, content: json]
    return response
}
